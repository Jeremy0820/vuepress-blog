---
title: 函数之自定义函数
date: 2016-05-02 15:33:48
permalink: /pages/03f9e5/
categories:
  - python
  - Python基础
tags:
  - 后端
  - Python
---

**函数**

​	函数就是将一些语句集合在一起的组件, 从而让他们能够不止一次地在程序中运行. 本质上函数就是在编程过程中交替地复制, 粘贴, 不再有一个操作的多个冗余副本, 而是将代码包含到一个单独的函数中. 这样, 我们就可以大大减少之后的工作量. 函数是python为了达到代码重用最大化而提供的最基本的程序结构.

**为何使用函数**

​	函数是一个通用的程序结构组件, 有时也被称为子程序或过程. 函数主要扮演了两个角色:

(1).最大化代码重用和最小化代码冗余
	和众多现代编程语言一样, Python的函数是一种简单的打包逻辑算法的方式, 使其能够在之后不止一处, 不止一次地使用. 直到现在, 我们所写的代码都是立即运行的. 函数允许我们整合并通用化代码, 以便这些代码能在之后多次使用. 因为他们允许一处编写多处运行, Python的函数是这个语言中最基本的组成工具— 他让我们在程序中减少冗余代码, 进而减少代码的维护成本.

(2).过程的分解
	函数也提供了一种将一个系统分割定义完好的不同部分的工具. 一般来说, 函数关注的过程: 关于如何做某件事, 而不是哪些对象做这件事.

**函数分类**

Python函数从大的方面分类, 分为两类:

-   自定义函数: 用户自己根据业务逻辑封装的函数
-   内置函数: Python解释器底层定义好的, 实现了一些简单的功能, 供开发人员调用

---

## 1.函数的定义与调用

### 1.1 函数的定义

```python
# 定义函数的语法
def function_name(params):
    statements
    return value

# 说明:
(1).def是关键字, 固定的不能更改
(2).function_name是函数名, 自定义, 但需要符合Python标识符命名规则
(3).params是参数, 按需传入, 如果函数不需要传参, 可以不传
(4).statements是要执行的逻辑代码块
(5).return用户返回一个值给调用者, 可选, 如果函数不需要返回值给用户, 可以不写, 不写默认返回None
注意: 上面是比较完整的函数结构, 函数比较灵活, 不需要定义的可以不写
    
# 示例: 定义一个函数, 接受两个整数, 计算两个数据的和, 并将和返回给调用者
def add_two_num(num1, num2):
    ret = num1 + num2
    return ret
```



### 1.2 函数的调用

```python
# 1.函数名的本质
函数是将一段逻辑代码封装起来的程序结构, 实际上封装后的代码的内存地址赋值给了函数名.

# 2.函数的调用
函数的调用非常简单, 直接使用函数名加括号, 并按需在括号内传入指定的参数即可调用, 如上面的示例, 调用方式如下:
add_two_num(1, 2)
```



---

## 2.函数的参数

### 2.1 函数参数的分类

```python
# (1).函数参数分类: 按定义的阶段划分
	- 形参: 在定义函数时, 作为传入函数内参数的代表出现
    - 实参: 在调用函数时, 实际传入函数的具体的值
# 说明:
	上面的例子中, def add_two_num(num1, num2)中的num1, num2被称作为形参, 而调用函数时add_two_num(1, 2)这里的1和2被称作为实参.
        
# (2).函数参数分类: 按照传入函数的方式不同划分
	- 位置参数: 按照函数参数的位置进行传递, 传递的参数会与定义时的位置一一对应.
    - 关键字参数: 传递参数时, 使用"参数名=参数值"的形式进行传递
    - 缺省参数: 缺省参数又称为"默认值参数", 即在定义函数是已经给该参数指定了默认的值, 在调用函数时, 如果用户传递了新的值, 则使用用户传递的值, 如果用户没有传递, 则使用默认值.
    - 动态位置参数: 当位置参数的个数是不确定时, 使用动态位置参数, 一般在参数名前'*', 按照惯例通常使用"*args"代表动态位置参数, 当然args你也可以使用其他的名字, 但不建议更改.
    - 动态关键字参数: 当关键字参数个数不确定时, 使用动态关键字参数, 一般参数名前加'**', 按照惯例通常使用"*kwargs"代表动态位置参数, 当然kwargs你也可以使用其他的名字, 但不建议更改.
```

### 2.2 几种参数详解

```python
# 1.位置参数: 按照位置进行传参
def add_two_num(num1, num2):
    ret = num1 + num2
    return ret

res = add_two_num(1, 2)

# 解释:
按照位置传参, Python解释器在执行函数时, 会根据传递参数的位置对应定义函数时的顺序, 即上面的例子中, num1=1, num2=2
```

```python 
# 2.关键字传参
def add_two_num(num1, num2):
    ret = num1 + num2
    return ret

res = add_two_num(num2=1, num1=2)

# 解释:
按参数的名字进行传参, Python解释器在执行函数时, 会根据参数的名字, 将值赋值给指定的参数, 即上面的例子中, num1虽然定义在第一个位置上, 但调用时指定了num1的值是2, 而num2的值为1
```

```python
# 3.缺省参数: 计算a的b次方的结果返回给用户
def num_squ(a, b=2):
    ret = a ** b
    
ret1 = num_squ(2)  # ret1的值为4
ret2 = num_squ(2, 3)  # ret2的值为8

# 解释:
第一次调用函数时, 只指定了a的值为2, 没有传入b的值, 则在函数内部使用定义函数时的默认参数, 即b=2, 所以结果为2的平方, 结果为4
第二次调用函数是, 根据位置传递参数, a的值为2, b的值为3, 所以计算的结果为2的3次方, 结果为8.
```

```python
# 4.动态位置参数
def num_n(*args):
    print(args)
    ret = sum(args)
    
    
num_n(1, 2, 3, 4)

# 说明:
无论调用num_n时传入多少个整数, 都会被args接收到, 并且args是所有参数集合在一起的一个元组.
```

```python
# 5.动态关键字参数
def num_n(**kwargs):
    print(kwargs)


num_n(a=1, b=2, c=3)

# 说明:
无论num_n接收多少个关键字参数, 最后都会被kwargs接收到, 并形成一个字典, 字典的键就是关键字参数的名字, 值是关键字参数的值.
```

### 2.3 函数参数规则

函数参数的定义与传递都要遵循一定的顺序规则, 顺序如下:

位置参数 -> 关键字参数(缺省参数) -> 动态位置参数 -> 动态关键字参数

---

## 3.函数的返回值

函数的返回值不是必须的, 是否要返回给用户可以根据业务需求而定. 不过几种返回形式不要说明一下:

```python
# 1.返回一个值
def func(a):
    return a + 1
ret = func(1)  # ret的值为2

# 2.返回两个或多个
def func():
    return 1, 2, 'hello'
ret = func()  # ret是一个元组, 即 ret == (1, 2, 'hello')
a, b, c = func()  # 可以使用解构拆分出所有的值, 复制给不同的变量. a == 1, b == 2, c == 'hello'


# 3.返回None的情况
(1).不写return, 默认返回None
(2).写return, 但return后不写返回的值, 则返回个调用者None
(3).直接: return None
```



---

## 4.函数嵌套

函数的定义中, 在函数体中是业务逻辑, 即代码块. 那在代码块中还可以定义函数吗? 也就是函数内部再定义函数. 当然是可以的. 看下面的示例:

```python
def func1():
    print('函数1的函数体')
    def func2():
        print('func2的函数体')
	print('func2也属于func1的函数体代码, 还可以在下面调用func2的哦!')
	func2()


func1()

# 指定结果:
函数1的函数体
func2也属于func1的函数体代码, 还可以在下面调用func2的哦!
func2的函数体
    
        
# 代码的执行过程(如图所示):
1.定义func1
2.调用func1
3.执行func1
4.执行打印: 函数1的函数体
5.定义func2
6.执行打印: func2也属于func1的函数体代码, 还可以在下面调用func2的哦!
7.调用func2
8.执行func2中的打印: func2的函数体
```

![](https://cdn.jsdelivr.net/gh/Jeremy0820/blogpic/blog/image-20210504210158926.png)

---

## 5.作用域

### 5.1 命名空间与作用域

在讲解作用域之前我们先要了解一个叫做“命名空间”的概念.

**命名空间: **命名空间是指变量与其值之间的映射关系. 命名空间记录了变量与值之间的对应关系.

接下来我们了解一下“作用域”. 作用域是指变量在程序中能够作用的范围. 在python程序中, 不同的变量, 所能使用的范围是不一样的, 通常在Python中作用域分为一下几种:

-   局部作用域
-   嵌套作用域
-   全局作用域
-   内置作用域

```python
# 解释与说明:
- 局部作用域: 定义在函数内部或类内部的变量
- 嵌套作用域: 嵌套作用域也是定义在函数或类内部的变量, 但前提是这个函数外内部还有函数, 换句话说, 也就是当一个函数内部嵌套有其他函数时, 外层函数的函数体就从原来的局部作用域变为了嵌套作用域, 而内部函数的函数体就变成了局部作用域.
- 全局作用域: 全局作用域很难描述, 可以简单的理解为: 全局作用域就是你写的脚本中没有缩进的区域(for循环与if分支的缩进不算)定义的变量.
- 内置作用域: python解释器运行代码前加载的命名空间对应的作用域就是内置作用域.
```

### 5.2 LEGB法则

​	在Python中定义的变量, 所属与不同的作用域. 在不同的作用域中并不是刻意随意使用的. 接下来我们就来了解一下LEGB法则:

```python
# LEGB法则:
	LEGB法则是用来描述变量搜索顺序的. 其中不同的字符代表不同的作用域:
        - L: 局部作用域(Local)
        - E: 嵌套作用域(Enclosed)
        - G: 全局作用域(Global)
        - B: 内置作用域(Builtin)
    LEGB法则规定, 在局部作用域中使用一个变量, 如果当前局部作用域没有, 则到上一级嵌套作用域中寻找, 如果依然找不到, 则到全部作用域寻找, 如果还找不到, 则到全局作用域去寻找. 依次规律寻找变量, 但不能"逆行". 如下图所示:
```

![image-20210504213315702](https://cdn.jsdelivr.net/gh/Jeremy0820/blogpic/blog/image-20210504213315702.png)

---

## 6.匿名函数

### 6.1 匿名函数是个啥

在Python中函数是用来封装一段业务逻辑的代码块, 比如下面则个需求:

```python
# 需求: 计算一个数的平方
def squ(a):
    return a ** 2

	这个函数实现的功能非常简单, 两行代码搞定了, 这样总有些大财小用, 我们这里提供一种简单的实现方式, 我们称之为匿名函数. 如下所示:
lambda a: a ** 2
	仅仅一行就搞定了, 但是有的小朋友可能会问, 这个匿名函数的函数名呢? 小傻瓜, 匿名哪来的名字呀.... 可能又有小可爱要问了, 函数的调用不是要用函数名加括号吗? 我看你咋调用, 哈哈哈, 直接给他赋值给一个函数名不就行啦?
func = lambda a: a ** 2
func()  # 调用匿名函数
	你是不是又疑惑啦? 不是说叫"匿名函数"吗? 咋又给弄了一个名字....
    好啦, 不要纠结啦, 匿名函数旨在将简单的函数, 也这种方式来编写, 而不不是非要搞成没有名字. 这正体现了Python语言的特点:  简单优于复杂!
```



### 6.2 匿名函数的深层次讨论

我们之前讨论过函数名的本质: 函数定义的过程, 是将函数体代码块的内存地址赋值给了函数名, 函数名加了括号得意调用执行函数体的代码, 然而, 匿名函数直接返回了函数体的内存地址, 没有赋值给一个函数名, 所以称之为匿名函数.

匿名函数适用场景:

(1).简单的逻辑实现
	简单的逻辑实现, 没有必要封装称为一个函数. 这样就大材小用了. 函数更适合与复杂的业务逻辑封装.

(2).在def关键字不可以出现的地方
	比如说, 我们要在一个列表中放置多个函数, 列表中没有办法定义def函数, 我们就可以使用匿名函数. 比如下面的示例:

```python
# 需求: 定义三个函数, 放在列表中循环调用, 每个函数都传入一个参数, 这个参数就是函数在列表中的索引, 第一个函数返回其索引值与1的和, 第二个返回索引值的平方, 第三个返回索引值模3后的余数
func_lst = [lambda idx: idx + 1, lambda idx: idx ** 2, lambda idx: idx % 3]
for func in func_lst:
    idx = func_lst.index(func)
    print(func(idx))

# 结果:
1
1
2
```